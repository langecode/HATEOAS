{
  "swagger" : "2.0",
  "info" : {
    "description" : "#Description\nThis \"Simple Banking API Sample\" serves to exemplify a way of using HATEOAS in the form of HAL in the API in and easy and intuitive way. [Read more](https://github.com/Nykredit/HATEOAS/wiki)\nFurthermore it points to elaborated examples and what would be nice to have supported in a better way in the REST implementations and possibly in Swagger in order have an easy way to use the full potential of HATEOAS in the form of HAL and services.\n\n    \n## API Description\n    \nThis API show a very simple set of resources that emulates three micro-services which are: account, payment and Person.\nThe Idea is to create everything as one large single Swagger file and decompose that into some sections: e.g. a general section, \na capabilities section, where the various API capabilities can be imported etc. [Read more about the Capabilities](https://github.com/Nykredit/HATEOAS)\n\n## General Principles\n\nA semantic REST API is using and thus also HATEOAS in form of the hal specification.\nThe API can be versioned at the structural level by means of a HTTP Header and at the content level in each endpoint by means of the content-type.\n\n## HTTP Headers used\n\nA number os headers are used.\n\n* `X-Log-Token` for correlating a number activities between service and consumers of the service.\n* `X-Client-Version` for identification of a client version and its contract.\n* `X-Service-Generation` to signal a non-current structure of the API (saves known redirects from a client perspective)\n\n* `Accept` is used to signal what content the consumer wished and the version and projection can be specified. \n### Correlation between service (Server) and consumer (Client)\n\nA `X-Log-Token` header is used to give a client the opportunity to find a number of calls and activities related to calls belonging to that context.\nIf the client includes a `X-Log-Token` header and a value associated with that, the value will be extended with a timetick initially to ensure uniqueness.\nThe original `X-Log-Token` is returned in every response from the service, the client must include the unique token received in the response in the \nfollowing requests if the correlation is still what the client wants. If the client does not include a `X-Log-Token` the service creates a unique token\nand returns that in the response and the client can use that.  \n\n### Client Identifier\n\nThe `X-Client-Version` header is used for identification of the client version and is required in order for a client to successfully operate on resources. The version in according to semver-org\n\n### Versions\n\nThere exists two major forms of versioning: one is related to the structure of the API, the other is related to the contents in each endpoint in the API.\n\nThe two different aspects are handled in each their dedicated fashion. \n\nThe `X-Service-Generation` HTTP header is used for signalling the version of the API structure instead of having the version as a part of the baseURL. \n\nThe content-type includes version information and is returned in every response from the service. The content-type can do that is a couple of ways: \n\n  * using `\"_links\": { \"href\": \"...\"}` with no `\"type\"` will point to the newest and current content at the referenced endpoint.\n\n  * using  `\"_links\": { \"href\": \"...\", \"type\": \"application/hal+json;v=1\"}` with `\"type\"` will point to the version listed and in this case that is the version 1 at the referenced endpoint.\n\n  The client must know if a problem has occurred in a situation, where the contents from a service endpoint was updated in a way that this particular client could not cope with and therefore it must know what version works and this the hal specification can be used decorate the `\"_links\":` object with the version of the content that it understands. That lets the client include the understandable content-type as defined in `\"_links\":` and include that as the value of the \"Accept\" header.\n  An example of such client side decorated response from a server, where the default and newest content-type are \"overwritten\" by the type for the users.\n\n\n    {\n      \"label\": \"Budget Account\",\n      \"currency\": \"DKK\",\n      ...\n      \"_links\": {\n        \"transactions\": [{\n            \"href\": \"accounts/1234-567890/transactions/987654321\"\n          }, {\n            \"href\": \"accounts/1234-567890/transactions/987654322\"\n          }, {\n            \"href\": \"accounts/1234-567890/transactions/987654323\"\n          }\n        ],\n        \"users\": {\n          \"primary\": {\n            \"href\": \"users/hans-b-hansen-13-09-1234\",\n            \"type\": \"application/hal+json;v=1\"\n          },\n          \"coUsers\": [{\n              \"href\": \"users/frederikke-b-hansen-16-07-6789\",\n              \"type\": \"application/hal+json;v=1\"\n            },{\n              \"href\": \"users/ulla-b-hansen-23-03-4567\",\n              \"type\": \"application/hal+json;v=1\"\n            }]\n        }\n      }\n    }\n\nIf a projection (a given view on e.g. the user is needed) that may be included in the content-type as well, if a matching producer is available in the service that will be used. the version is referring to the structures and contents of the json response from a given endpoint. It is not the historical state of a user object. Examples of the versions of content by value in the `Accept` header below:\n\n* `\"application/hal+json;concept=user;v=1\"` for the complete user json in hal format\n\n* `\"application/hal+json;concept=user-basic;v=1\"` for the basic user information in hal json format\n\n* `\"application/hal+json;concept=user-basic\"` for the newest version of basic user information in hal format\n\n* `\"application/hal+json\"` for the newest version of user information in hal format\n\n\nIt is possible to express the same without using the parameters as shown above using - although less elegant and less HTTPish:\n\n\n* `\"application/hal+json+user+1\"` for the complete user json in hal format\n\n* `\"application/hal+json+user-basic+1\"` for the basic user information in hal json format\n\n* `\"application/hal+json+user-basic\"` for the newest version of basic user information in hal format\n\n## API Capability Set\n\nIn every API of a certain size a number of capabilities are used. These capabilities consists of a particular set of functionality. This functionality can be divided into the following capabilities:\n\n\n\n     Selection:    `select` \n                   - selecting objects by attribute value(s) for response\n\n     Sorting:      `sort` \n                   - sorts objects descending and ascending by \n                     attribute(s) for response\n\n     Temporal:     `interval` \n                   - limits relevant objects in desired response\n                     to be within a certain time frame\n\n     Pagination:   `elements` \n                    - specifies the elements in a range desired \n                      to be in response\n\n     Filtering:   `filter` \n                   - ask for exclusion or inclusion of particular\n                     attributes or objects in response\n\n     Composition: `embed` \n                  - ask for the inclusion of \"related\" objects and \n                    projection into the response.\n\n\nThese capabilities may be applied individually to endpoints in APIs.\nThe user of the API endpoint can see what capability/ies is/are supported at each endpoint by looking at the for tags like select, sort, paginate etc. The Swagger tags are used here to achieve an easy way to show the capabilities in each endpoint as can be seen further down in the Swagger specification.\n\nAnother perspective that is often seen in APIs is the use of technical keys (potentially UUIDs) which are semantically poor, but often seen as a necessity for sensitive keys such as social security numbers. In order to avoid having these sensitive information leaked to logs and other places, there is a need for bringing these keys into the body of a request and a non-sensitive key is going to help. The problem with an UUID'ish key is that the developer experience is not optimal. Therefore it would be a nice thing to get some form of consensus on a derived capability like :\n\n      Sensitive Semantic ID deconstruction \n      - generation of non-sensitive semantic key for objects that has a sensitive\n        semantical key in the form of something that has a better developer\n        experience than e.g. UUIDs can offer.\n\n### Selection API Capability\n\nSelection by criteria(s) is done using a Query Parameter called `select`. \n\n    The syntax is: select=\"<attribute>::<value>|<atribute>::<value>|...\"\n\n\nThe usage can be exemplified by e.g. asking for accounts having a balance equal to 100.\nCurrency is omitted here on purpose.\n\n\n#### The concrete url would look like: \n\n     <https://banking.services.sample-bank.dk/\n              accounts?select=\"balance::100\">\n     \n     \"balance::100\"\n     which returns accounts having a exact balance of 100.\n#### Another example:\n    <https://banking.services.sample-bank.dk/\n             accounts?select=\"balance::100+|balance::1000-\">\n    \n    select=\"balance::100+|balance::1000-\"\n    which returns accounts having a balance between 100 and 1000 (both inclusive).\n    \n#### Yet another example:\n    <https://banking.services.sample-bank.dk/\n             accounts?select=\"no::123456789+|no::234567890\">\n    \n    select=\"no::123456789+|no::234567890\"\n    which returns the to accounts having account numbers \"123456789\" and \"234567890\" and thus it works as a way to select certain objects, in this case based on the semantic key for an account which is the number of that account.\n\n### Sorting API Capability\n\nSorting is done using a `sort` Query Parameter.\nSorting can be done ascending (default) or descending\n\n      The syntax is: sort=\"<attribute>+/-|<attribute>+/-|...\"\n      and is equivalent to: sort=\"<attribute>::+/-|<attribute>::+/-|...\"\n\nThe usage can be exemplified as an\n\n#### Example:\n\n    <https://banking.services.sample-bank.dk/\n             accounts?sort=balance>\n    which returns an ascending set of accounts sorted by balance\n\n\n#### Another example is: \n\n    <https://banking.services.sample-bank.dk/\n             accounts?select=balance|lastUpdate->\n    which returns a set of account sorted descending by\n    lastUpdate and ascending by balance. \n\n### Temporal API Capability\n\nTemporal aspects are handled using the `interval` Query Parameter.\n\n\n      The syntax is: interval=\"<now/from/to/at/::+/-/#d/#/now>|\n                               <now/from/to/at/::+/-/#d/#>\"\n\n#### Example:\n\n    <https://banking.services.sample-bank.dk/\n             accounts/1234-56789/transactions?interval=\"from::-14d|to::now\">\n    which returns the transactions from a specific account within the last 14 days\n\n#### Another example:\n\n    <https://banking.services.sample-bank.dk/\n             accounts/1234-56789/transactions?interval=\"from::1476449846|to::now\">\n    \n    <https://banking.services.sample-bank.dk/\n             accounts/1234-56789/transactions?interval=\"from::1476449846\">\n    \n    <https://banking.services.sample-bank.dk/\n             accounts/1234-56789/transactions?interval=\"at::1476449846\">\n    \n    The latter three returns the transactions from a specific account \n    within the last day assuming now is friday the. \n    14th of October 2016 UTC time.\n\n### Pagination API Capability \n\nPagination of responses is obtained by using the Query parameter `elements`.\nThe Query Parameter `elements` signals the initial element and the last element that is desired to be part of the response.\n\n    The syntax is: elements=\"<startingFrom>|<endingAt>\" both inclusive.\n\n#### Example:\n\n     <https://banking.services.sample-bank.dk/\n              accounts/1234-56789/transactions?elements=\"10|30\"> \n     which returns element 10 as the first entry in the json \n     response and element 30 as the last entry in the response.\n\n\nA maximum element size is defined here max size is 500 elements\n\n### Filtering API Capability\n\nThe Query parameters `filter` is used for signalling to the server that a dynamic projection is desired as the response from the service. The service is not obliged to be able to do that, but may return the standard projection of the objects given for that concrete endpoint. This can be used for discovery of what projections service consumers would like to have and help evolving the API to stay relevant and aligned with the consumers use of the service.\n\n    The syntax is: filter=\"<attribute>::+/-|<attribute>::+/-\" \n    + means include only\n    - means exclude only\n    \n\n\n#### Example:    \n\n    <https://banking.services.sample-bank.dk/\n             accounts/1234-56789?filter=\"balance::-|name::-\"> \n    which ideally returns a account object in the response without balance \n    and name attributes.\n    The service may however in the event that this is not supported,\n    choose to return a complete object and not this sparse dynamic view. \n\n\n#### Example:\n\n    <https://banking.services.sample-bank.dk/\n             accounts/1234-56789?filter=\"balance::+|name::+\">\n    which ideally returns a account object in the response with only balance\n    and name attributes.\n    The service may however in the event that this is not supported,\n    choose to return a complete object and not this sparse dynamic view. \n### Composition  API Capability \n\nComposition is about enabling the consumers of services, the Query Parameter `embed` is used to signal to the service that the consumer would like to have a certain assumed related object included as a part of the response if possible.\n\n    The syntax is: embed=\"<concept>::<projection>|<concept>::<projection>|...\" \n    \n    \n#### Example:\n\n    <https://banking.services.sample-bank.dk/\n             accounts/1234-56789?embed=\"transaction::list|owner::sparse\"\n    \n    embed=\"transaction::list|owner::sparse\"\n    which ideally will return a json response including `_links` and `_embeddded` objects inside the response containing either a map or array of transactions with links in the `_links` object and the desired projection in the `_embedded` object for both owner and transactions. \n    \n  \nThe service can choose to return just the accounts including links to transactions under the `_links` object as this is allowed by HAL. The Query Parameter can be used for evolving the service to match the desires of consumers - if many consumers are having the same wishes for what to embed - the owners of the service could start considering whether they want to include more in the responses and endure the added coupling between this service and the service that may deliver the embedded information. This coupling should of course not be synchronous.\n\n### Sensitive Id decomposition \n\nThe creation of an id can be challenging especially if the true semantic id is protected by law, which is the case for people. Therefore a either a UUID is suggested or a semi-semantic approach like firstName-middleName-sirName-dayInMonth-MonthInYear-Sequence, that allows for a human readable - yet not revealing id for a person.\n\nOther suggested methods for doing has been to create a hash(sensitive semantic key), which might work but will be vulnerable for a brute force reengineering effort. The response to that is often to salt it, that is salt(hash(sensitive sementic key)), and that is ok but is seems merely to be a very difficult way to create a UUID, which means we have a key that is developer unfriendly - at least compared to the more human readable key consisting of recognizable fragments from the real world.\n\nThe suggested approach is firstname-middlename-familyname-ddMM-sequencenumber\n\n#### Example:\n\n    hans-p-hansen-0112 the initial created Hans P Hansen born on the 1st of December\n    hans-p-hansen-0112-1 the second created Hans P Hansen born on the 1st of December\n    hans-p-hansen-0112-94 the 95th created Hans P Hansen born on the 1st of December\n \n    mike-hansson-0309 the initially created Mike Hansson born on the 3rd of September\n \n\n## Resilience\n\n\n### Limits\n\nThe server-side service might be busy for one or the other reason and need to tell the client that. In fact it is trying to say \"Be patient - I am rather busy right now\". Therefore the server returns a `503` error code (see response codes below) with a *Retry-After* header stating the time\nwhen it is expected that the server is no longer busy and can serve a consumer again.\n\nIf the server-side intercepts the consumer it may choose to return a 429 Too many Requests with a response stating that \"You are limited to XXXX requests per hour per `access_token` or `client_id` in total per  per `timeunit` overall. \n\n## Responses\n\nThe responses from calling resources in the API adheres to the specification of HTTP 1.1 and thus the status code, the headers used are found in that specification.\n\n### Status Codes\n\n#### Information on status code and headers are found under:\n\n      Status codes:\n      <https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html>\n      \n      Headers:\n      <https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html>\n\n\nA couple of response codes will be described here as inspiration, but the most important thing is to work with the protocol and thus to read and understand what the status codes means and how they fit into the current situation in the API and write explicitly what the client can expect in every situation in order to make the API as developer friendly as possible. \n\n#### 200 OK\n\nThe 200 OK response signal everything went ok and there will usually be a response that contains a body corresponding to the initiating request's `Accept` header.\n\n#### 201 Created\n\nThe 201 Created follows after a successful `POST` or `PUT` and states where the newly resource was created in a `Location` header.\n\n#### 202 Accepted\n\nThe 202 Accepted response signals that the request was understood and the response will follow later, the response should state information can be obtained later concerning the request for the resource returning the 202. This is signalled in the `Location` header, to be nice the expectations of the client can be set using the `Retry_After` and issue a timeframe for when it makes sense to ask for a status again from the client.\n\n##### Headers\n\n```\nLocation: http://get/the/new/status/location\n\nRetry-After: 30\n```\n\n#### 301 Moved Permanently\n\nThe 301 is issued if a client asks for a resource that is no longer at the place it used to be. AS an example this could be a resource that has moved to a different part of the API. In that case a 301 is returned with a `Location` header containing the new position.\n\n##### Headers\n\n```\nLocation: http://this/is/the/new/location\n```\n\n#### 400 Bad Request\n\nThe 400 response states that this request was wrong and should not be retried\n\n#### 401 Unauthorized\n\nThe 401 response states that this request did not have user authentication and that usually means that the client needs to either have a contract for that resource, authenticate the user, renew a token or ... in order to get access to the requested resource.\n\n\n#### 403 Forbidden\n\nThe 403 response states that this request have user authentication but does not have sufficient authorizations to access the resource.\n\n#### 404 Not Found\n\nThe 404 response states that the resource requested did not exist.\n\n#### 409 Conflict\nThe 409 response states that the attempted request for the resource is resulting in a form of conflict, which the client must resolve before retrying. This could be trying to POST changes to an object that would cause the object to be in an erroneous state.\n\n#### 503 Service Unavailable\nThe 503 response states that the server for some reason is unavailable.\n\n##### Headers\n\n```\nRetry-After: Sat, 31 Dec 2016 23:59:59 GMT\n```\n\nor\n\n```\nRetry-After: 120\n```\n\n## Service terms\n\nThe terms of using the service is as follows, the contract found at <https://sample-bank.dk/services/contracts/2345678> states the general terms for using this service. Consumers can create their own individual contract and terms for usage at <https://sample-bank.dk/services/consumers>\n  ",
    "version" : "1.0.0-SNAPSHOT",
    "title" : "HATEOAS(HAL) Sample",
    "termsOfService" : "he terms of using the service is as follows,\n                                    the contract found at\n                                    https://sample-bank.dk/services/contracts/2345678\n                                    and states the general terms for using this service.\n                                    Consumers can create their own individual contract and terms\n                                    for usage at https://sample-bank.dk/services/consumers",
    "contact" : {
      "name" : "Sample Bank Contact Name",
      "url" : "https://www.sample-bank.dk",
      "email" : "sample@sample-bank.dk"
    },
    "license" : {
      "name" : "(C) Sample-Bank 2016",
      "url" : "https://www.sample-bank.dk/licenses/LICENSE.html"
    }
  },
  "host" : "hateoas.services.nykredit.dk",
  "basePath" : "/hateoas",
  "tags" : [ {
    "name" : "accounts"
  }, {
    "name" : "decorator"
  }, {
    "name" : "elements"
  }, {
    "name" : "embed"
  }, {
    "name" : "events"
  }, {
    "name" : "filter"
  }, {
    "name" : "immutable"
  }, {
    "name" : "interval"
  }, {
    "name" : "reconciled"
  }, {
    "name" : "select"
  }, {
    "name" : "sort"
  }, {
    "name" : "transactions"
  } ],
  "schemes" : [ "https" ],
  "paths" : {
    "/account-events" : {
      "get" : {
        "tags" : [ "interval", "events" ],
        "summary" : "obtain all events emitted by the account-event service",
        "description" : " the events are signalled by this resource as this this is the authoritative resource for all events that subscribers to the account service should be able to listen for and react to. In other words this is the authoritativefeed for the account service",
        "operationId" : "listAllEvents",
        "produces" : [ "application/hal+json" ],
        "parameters" : [ {
          "name" : "interval",
          "in" : "query",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "successful operation",
            "schema" : {
              "$ref" : "#/definitions/Events"
            }
          }
        },
        "security" : [ {
          "Bearer" : [ ]
        }, {
          "oauth" : [ ]
        } ]
      }
    },
    "/account-events/{category}" : {
      "get" : {
        "tags" : [ "interval", "events" ],
        "summary" : "obtain all events scoped to a certain category",
        "description" : " the events are signalled by this resource as this this is the authoritative resource for all events that subscribers to the account service should be able to listen for and react to. In other words this is the authoritativefeed for the account service, allowing for subscribers to have these grouped into categories",
        "operationId" : "getEventsByCategory",
        "produces" : [ "application/hal+json" ],
        "parameters" : [ {
          "name" : "category",
          "in" : "path",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "interval",
          "in" : "query",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "successful operation",
            "schema" : {
              "$ref" : "#/definitions/Events"
            }
          }
        },
        "security" : [ {
          "Bearer" : [ ]
        }, {
          "oauth" : [ ]
        } ]
      }
    },
    "/account-events/{category}/{id}" : {
      "get" : {
        "tags" : [ "immutable", "events" ],
        "summary" : "obtain the individual events from an account",
        "description" : "the event her is immutable and thus can be cached for a long time",
        "operationId" : "getEvent",
        "produces" : [ "application/hal+json" ],
        "parameters" : [ {
          "name" : "category",
          "in" : "path",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "successful operation",
            "schema" : {
              "$ref" : "#/definitions/Event"
            }
          },
          "404" : {
            "description" : "No event found."
          }
        },
        "security" : [ {
          "Bearer" : [ ]
        }, {
          "oauth" : [ ]
        } ]
      }
    },
    "/accounts" : {
      "get" : {
        "tags" : [ "accounts" ],
        "summary" : "lists accounts",
        "description" : "List all accounts in a default projection, which is AccountOverview version 1Supported projections and versions are: AccountOverview in version 1 The Accept header for the default version is application/hal+json;concept=AccountOverview;v=1.0.0.... The format for the default version is {....}",
        "operationId" : "listAccounts",
        "produces" : [ "application/hal+json" ],
        "responses" : {
          "200" : {
            "description" : "successful operation",
            "schema" : {
              "$ref" : "#/definitions/Accounts"
            }
          }
        },
        "security" : [ {
          "oauth" : [ "advisor" ]
        } ]
      }
    },
    "/accounts/{regNo}-{accountNo}" : {
      "get" : {
        "tags" : [ "accounts" ],
        "summary" : "gets the information from a single account",
        "description" : "obtain a single account back in a default projection, which is Account version 2 Supported projections and versions are: AccountSparse in version1 and Account in version 2 The format of the default version is .... ",
        "operationId" : "getAccount",
        "produces" : [ "application/hal+json" ],
        "parameters" : [ {
          "name" : "regNo",
          "in" : "path",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "accountNo",
          "in" : "path",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "successful operation",
            "schema" : {
              "$ref" : "#/definitions/Account"
            }
          },
          "404" : {
            "description" : "No account found."
          }
        },
        "security" : [ {
          "oauth" : [ "customer", "advisor" ]
        } ]
      },
      "put" : {
        "tags" : [ "accounts" ],
        "summary" : "Create new or update existing account",
        "description" : "PUT is used to create a new account from scratch and may be used to alter the name of the account",
        "operationId" : "updateAccount",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/hal+json" ],
        "parameters" : [ {
          "name" : "regNo",
          "in" : "path",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "accountNo",
          "in" : "path",
          "required" : true,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "body",
          "description" : "account",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/AccountUpdate"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "successful operation",
            "schema" : {
              "$ref" : "#/definitions/Account"
            }
          },
          "201" : {
            "description" : "New Account Created",
            "schema" : {
              "$ref" : "#/definitions/Account"
            }
          },
          "400" : {
            "description" : "Could not update or create the account",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "oauth" : [ "customer", "system", "advisor" ]
        } ]
      }
    },
    "/accounts/{regNo}-{accountNo}/reconciled-transactions" : {
      "get" : {
        "tags" : [ "select", "sort", "elements", "interval", "filter", "embed", "decorator", "reconciled" ],
        "summary" : "obtain reconciled transactions (added API capabilities not though not implemented)",
        "description" : "obtain a list of all reconciled transactions from an accountthe reconciled transactions are user controlled checks and notes for transactions such as - Yes I have verified that this transaction was correct and thus it is reconciled",
        "operationId" : "listReconciledTransactions",
        "produces" : [ "application/hal+json" ],
        "parameters" : [ {
          "name" : "regNo",
          "in" : "path",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "accountNo",
          "in" : "path",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "successful operation",
            "schema" : {
              "$ref" : "#/definitions/ReconciledTransactions"
            }
          }
        },
        "security" : [ {
          "oauth" : [ "customer", "advisor" ]
        } ]
      }
    },
    "/accounts/{regNo}-{accountNo}/reconciled-transactions/{id}" : {
      "get" : {
        "tags" : [ "decorator", "reconciled" ],
        "summary" : "obtain a single reconciled transaction from a given account",
        "description" : "",
        "operationId" : "getReconciledTransaction",
        "produces" : [ "application/hal+json" ],
        "parameters" : [ {
          "name" : "regNo",
          "in" : "path",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "accountNo",
          "in" : "path",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "successful operation",
            "schema" : {
              "$ref" : "#/definitions/Reconciledtransaction"
            }
          },
          "404" : {
            "description" : "No reconciled transaction found."
          }
        },
        "security" : [ {
          "oauth" : [ "customer" ]
        } ]
      },
      "put" : {
        "tags" : [ "decorator", "reconciled" ],
        "summary" : "Create new or update reconciled transaction",
        "description" : "reconciled transactions are user controlled checks and notes for transactionssuch as - Yes I have verified that this transaction was correct and thus it is reconciled",
        "operationId" : "updateReconciledTransaction",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/hal+json" ],
        "parameters" : [ {
          "name" : "regNo",
          "in" : "path",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "accountNo",
          "in" : "path",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "body",
          "description" : "reconciled transaction",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/ReconciledtransactionUpdate"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "successful operation",
            "schema" : {
              "$ref" : "#/definitions/Reconciledtransaction"
            }
          },
          "400" : {
            "description" : "No updating possible",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "oauth" : [ "system" ]
        } ]
      }
    },
    "/accounts/{regNo}-{accountNo}/transactions" : {
      "get" : {
        "tags" : [ "sort", "elements", "interval", "transactions" ],
        "summary" : "obtain all transactions on account for a given account",
        "description" : "",
        "operationId" : "listTransactions",
        "produces" : [ "application/hal+json" ],
        "parameters" : [ {
          "name" : "regNo",
          "in" : "path",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "accountNo",
          "in" : "path",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "sort",
          "in" : "query",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "elements",
          "in" : "query",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "interval",
          "in" : "query",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "successful operation",
            "schema" : {
              "$ref" : "#/definitions/Transactions"
            }
          }
        },
        "security" : [ {
          "oauth" : [ "customer", "advisor" ]
        } ]
      }
    },
    "/accounts/{regNo}-{accountNo}/transactions/{id}" : {
      "get" : {
        "tags" : [ "immutable", "transactions" ],
        "summary" : "obtain the individual single transaction from an account",
        "description" : "",
        "operationId" : "getTransaction",
        "produces" : [ "application/hal+json" ],
        "parameters" : [ {
          "name" : "regNo",
          "in" : "path",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "accountNo",
          "in" : "path",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "successful operation",
            "schema" : {
              "$ref" : "#/definitions/Transaction"
            }
          },
          "404" : {
            "description" : "No transaction found."
          }
        },
        "security" : [ {
          "oauth" : [ "customer", "advisor" ]
        } ]
      },
      "put" : {
        "tags" : [ "immutable", "transactions" ],
        "summary" : "creates a single transaction on an account",
        "description" : "",
        "operationId" : "setTransaction",
        "consumes" : [ "application/json" ],
        "produces" : [ "application/hal+json" ],
        "parameters" : [ {
          "name" : "regNo",
          "in" : "path",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "accountNo",
          "in" : "path",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "body",
          "description" : "transaction",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/TransactionUpdate"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "successful operation",
            "schema" : {
              "$ref" : "#/definitions/Transaction"
            }
          },
          "201" : {
            "description" : "New transaction created.",
            "schema" : {
              "$ref" : "#/definitions/Transaction"
            }
          },
          "202" : {
            "description" : "The input has been accepted and a new transaction will most likely be created."
          },
          "400" : {
            "description" : "Could create the new transaction",
            "schema" : {
              "$ref" : "#/definitions/Error"
            }
          }
        },
        "security" : [ {
          "oauth" : [ "system" ]
        } ]
      }
    }
  },
  "securityDefinitions" : {
    "Bearer" : {
      "type" : "apiKey",
      "name" : "Authorization: Bearer",
      "in" : "header"
    },
    "oauth" : {
      "type" : "oauth2",
      "authorizationUrl" : "https://banking.services.sample-bank.dk/token.oauth2?grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Ajwt-bearer&assertion=JWT",
      "flow" : "implicit",
      "scopes" : {
        "customer" : "get access to own account",
        "system" : "create account events and transactions",
        "advisor" : "get access on a owner's behalf"
      }
    }
  },
  "definitions" : {
    "Account" : {
      "type" : "object",
      "properties" : {
        "regno" : {
          "type" : "string",
          "example" : "1234",
          "description" : "Read-only"
        },
        "accountno" : {
          "type" : "string",
          "example" : "12345678",
          "description" : "Read-only"
        },
        "name" : {
          "type" : "string",
          "example" : "NemKonto",
          "description" : "Readable and Writeable"
        },
        "_links" : {
          "type" : "object",
          "properties" : {
            "account:transactions" : {
              "$ref" : "#/definitions/HALLink"
            },
            "self" : {
              "$ref" : "#/definitions/HALLink"
            }
          }
        }
      },
      "description" : "the Account"
    },
    "AccountUpdate" : {
      "type" : "object",
      "required" : [ "accountno", "name", "regno" ],
      "properties" : {
        "regno" : {
          "type" : "string",
          "example" : "1234",
          "description" : "Read-only",
          "pattern" : "^[0-9]{4}$"
        },
        "accountno" : {
          "type" : "string",
          "example" : "12345678",
          "description" : "Read-only",
          "pattern" : "^[0-9]+$"
        },
        "name" : {
          "type" : "string",
          "example" : "NemKonto",
          "description" : "Readable and Writeable",
          "pattern" : ".{1,40}"
        }
      },
      "description" : "the inout necessary for creating an Account"
    },
    "Accounts" : {
      "type" : "object",
      "properties" : {
        "_embedded" : {
          "type" : "object",
          "properties" : {
            "accounts" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/Account"
              }
            }
          }
        },
        "_links" : {
          "type" : "object",
          "properties" : {
            "self" : {
              "$ref" : "#/definitions/HALLink"
            }
          }
        }
      },
      "description" : "a list of Accounts in default projection"
    },
    "Error" : {
      "type" : "object",
      "properties" : {
        "sid" : {
          "type" : "string",
          "description" : "Read-only"
        },
        "message" : {
          "type" : "string",
          "example" : "this error happened due to this situation",
          "description" : "Read-only"
        },
        "_links" : {
          "type" : "object",
          "properties" : {
            "resource" : {
              "$ref" : "#/definitions/HALLink"
            },
            "values" : {
              "type" : "object",
              "description" : "Read-only",
              "additionalProperties" : {
                "type" : "object"
              }
            }
          }
        }
      },
      "description" : "a simple error representation"
    },
    "Event" : {
      "type" : "object",
      "properties" : {
        "id" : {
          "type" : "string",
          "description" : "Readable and Writeable"
        },
        "time" : {
          "type" : "string",
          "description" : "Readable and Writeable"
        },
        "sequence" : {
          "type" : "string",
          "example" : 1,
          "description" : "Readable and Writeable"
        },
        "category" : {
          "type" : "string",
          "example" : "1234-12345678",
          "description" : "Readable and Writeable"
        },
        "_links" : {
          "type" : "object",
          "properties" : {
            "metadata" : {
              "$ref" : "#/definitions/HALLink"
            },
            "origin" : {
              "$ref" : "#/definitions/HALLink"
            },
            "self" : {
              "$ref" : "#/definitions/HALLink"
            }
          }
        }
      },
      "description" : "An immutable event"
    },
    "Events" : {
      "type" : "object",
      "properties" : {
        "_embedded" : {
          "type" : "object",
          "properties" : {
            "events" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/Event"
              }
            }
          }
        },
        "_links" : {
          "type" : "object",
          "properties" : {
            "self" : {
              "$ref" : "#/definitions/HALLink"
            }
          }
        }
      },
      "description" : "A set of immutable events"
    },
    "EventsMetadata" : {
      "type" : "object",
      "properties" : {
        "metadata" : {
          "type" : "string",
          "description" : "Read-only"
        },
        "_links" : {
          "type" : "object",
          "properties" : {
            "self" : {
              "$ref" : "#/definitions/HALLink"
            }
          }
        }
      },
      "description" : "A very simple way of delivering metadata to the consumer of a service"
    },
    "HALLink" : {
      "type" : "object",
      "properties" : {
        "href" : {
          "type" : "string",
          "xml" : {
            "attribute" : true
          }
        },
        "templated" : {
          "type" : "boolean",
          "xml" : {
            "attribute" : true
          },
          "default" : false
        },
        "type" : {
          "type" : "string",
          "xml" : {
            "attribute" : true
          }
        },
        "deprecation" : {
          "type" : "string",
          "format" : "url",
          "xml" : {
            "attribute" : true
          }
        },
        "name" : {
          "type" : "string",
          "xml" : {
            "attribute" : true
          }
        },
        "profile" : {
          "type" : "string",
          "format" : "uri",
          "xml" : {
            "attribute" : true
          }
        },
        "title" : {
          "type" : "string",
          "xml" : {
            "attribute" : true
          }
        },
        "hreflang" : {
          "type" : "string",
          "xml" : {
            "attribute" : true
          }
        }
      }
    },
    "ReconciledTransactions" : {
      "type" : "object",
      "properties" : {
        "reconciledtransactions" : {
          "type" : "array",
          "items" : {
            "$ref" : "#/definitions/Reconciledtransaction"
          }
        },
        "_links" : {
          "type" : "object",
          "properties" : {
            "self" : {
              "$ref" : "#/definitions/HALLink"
            }
          }
        }
      },
      "description" : "A list containing the mutable decorator instances each having link to their immutable counterpart transaction to keep its immutability"
    },
    "Reconciledtransaction" : {
      "type" : "object",
      "properties" : {
        "id" : {
          "type" : "string",
          "description" : "Read-only"
        },
        "note" : {
          "type" : "string",
          "description" : "Read-only"
        },
        "reconciled" : {
          "type" : "boolean",
          "description" : "Read-only",
          "default" : false
        },
        "_links" : {
          "type" : "object",
          "properties" : {
            "self" : {
              "$ref" : "#/definitions/HALLink"
            },
            "transaction" : {
              "$ref" : "#/definitions/HALLink"
            }
          }
        }
      },
      "description" : "A mutable decorator for a transaction to keep its immutability"
    },
    "ReconciledtransactionUpdate" : {
      "type" : "object",
      "required" : [ "note", "reconciled" ],
      "properties" : {
        "note" : {
          "type" : "string",
          "description" : "Read-only",
          "pattern" : ".{1,256}"
        },
        "reconciled" : {
          "type" : "string",
          "description" : "Read-only",
          "pattern" : "true|false"
        }
      },
      "description" : "A way to reconcile transactions"
    },
    "Transaction" : {
      "type" : "object",
      "properties" : {
        "id" : {
          "type" : "string",
          "description" : "Read-only"
        },
        "description" : {
          "type" : "string",
          "example" : "Starbucks Coffee",
          "description" : "Read-only"
        },
        "amount" : {
          "type" : "string",
          "example" : 123.45,
          "description" : "Read-only"
        },
        "_links" : {
          "type" : "object",
          "properties" : {
            "self" : {
              "$ref" : "#/definitions/HALLink"
            }
          }
        }
      },
      "description" : "An classical domain immutable transaction"
    },
    "TransactionUpdate" : {
      "type" : "object",
      "required" : [ "amount", "description" ],
      "properties" : {
        "description" : {
          "type" : "string",
          "example" : "Starbucks Coffee",
          "description" : "Readable and Writeable",
          "pattern" : ".{1,256}"
        },
        "amount" : {
          "type" : "string",
          "example" : 123.45,
          "description" : "Readable and Writeable",
          "pattern" : "^([0-9]{1,9})((\\.)([0-9]{2}))?"
        }
      },
      "description" : "the input necessary for creating a transaction"
    },
    "Transactions" : {
      "type" : "object",
      "properties" : {
        "_embedded" : {
          "type" : "object",
          "properties" : {
            "transactions" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/Transaction"
              }
            }
          }
        },
        "_links" : {
          "type" : "object",
          "properties" : {
            "self" : {
              "$ref" : "#/definitions/HALLink"
            }
          }
        }
      },
      "description" : "A set of immutable transactions"
    }
  }
}